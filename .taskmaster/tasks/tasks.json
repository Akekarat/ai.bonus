{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Environment Configuration",
        "description": "Set up the development environment and project structure for the Bonus mobile app, including necessary dependencies and configurations for both iOS and Android platforms.",
        "details": "1. Create a new mobile app project using React Native or Flutter (choose based on team expertise)\n2. Configure the project for both iOS and Android platforms\n3. Set up version control repository\n4. Install necessary dependencies:\n   - SQLite package for local database\n   - Navigation library\n   - Animation libraries for wheel spinning\n   - JSON parsing utilities\n5. Create folder structure:\n   - /assets (for images and config files)\n   - /components (for reusable UI components)\n   - /screens (for main app screens)\n   - /utils (for helper functions)\n   - /database (for SQLite implementation)\n6. Add config.json template file in assets folder\n7. Configure app icons and splash screen",
        "testStrategy": "Verify that the project builds successfully on both iOS and Android simulators/emulators. Confirm that all dependencies are correctly installed and accessible. Run basic smoke tests to ensure the app launches without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "SQLite Database Implementation",
        "description": "Implement the SQLite database to store game data persistently, including game instances, play status, and results.",
        "details": "1. Create a database helper class to manage SQLite operations\n2. Define database schema with the following tables:\n   - GameInstances (id, url_id, created_at, played_at, result_id)\n   - WheelSections (id, name, image_url, chance)\n3. Implement CRUD operations for each table\n4. Create functions for:\n   - Creating new game instances\n   - Updating game status after play\n   - Retrieving game results by URL ID\n   - Storing wheel configuration from JSON\n5. Add migration support for future schema changes\n6. Implement error handling and logging for database operations\n\nExample database initialization code:\n```\nclass DatabaseHelper {\n  static Future<Database> initializeDB() async {\n    String path = await getDatabasesPath();\n    return openDatabase(\n      join(path, 'bonus_app.db'),\n      onCreate: (database, version) async {\n        await database.execute(\n          \"CREATE TABLE GameInstances(id INTEGER PRIMARY KEY AUTOINCREMENT, url_id TEXT, created_at TEXT, played_at TEXT, result_id INTEGER)\",\n        );\n        await database.execute(\n          \"CREATE TABLE WheelSections(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, image_url TEXT, chance REAL)\",\n        );\n      },\n      version: 1,\n    );\n  }\n}\n```",
        "testStrategy": "Create unit tests for database operations: test creating new game instances, updating game status, and retrieving game results. Verify data persistence by restarting the app and confirming that previously stored data is accessible. Test edge cases like database corruption recovery and handling of invalid data.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "JSON Configuration Parser",
        "description": "Develop a parser to read and process the wheel configuration from a JSON file, including sections, chances, and associated images.",
        "details": "1. Create a configuration parser utility\n2. Define data models for wheel sections:\n```\nclass WheelSection {\n  final String id;\n  final String name;\n  final String imageUrl;\n  final double chance;\n  \n  WheelSection({required this.id, required this.name, required this.imageUrl, required this.chance});\n  \n  factory WheelSection.fromJson(Map<String, dynamic> json) {\n    return WheelSection(\n      id: json['id'],\n      name: json['name'],\n      imageUrl: json['image_url'],\n      chance: json['chance'].toDouble(),\n    );\n  }\n}\n```\n3. Implement functions to:\n   - Load JSON from assets folder\n   - Parse JSON into wheel section objects\n   - Validate JSON structure and required fields\n   - Handle errors gracefully with default configurations\n4. Add support for reloading configuration at runtime\n5. Implement chance normalization to ensure probabilities sum to 100%\n6. Store parsed configuration in the SQLite database",
        "testStrategy": "Test with valid and invalid JSON files to ensure proper parsing and error handling. Verify that all required fields are correctly extracted and that missing fields trigger appropriate defaults or errors. Test chance normalization by confirming that the sum of all chances equals the expected total.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Wheel UI Component Development",
        "description": "Create a visually appealing and interactive wheel component that displays the configured sections and supports spinning animation.",
        "details": "1. Create a custom wheel component using Canvas or SVG\n2. Implement the wheel UI with the following features:\n   - Dynamic rendering of sections based on configuration\n   - Display of section images within each segment\n   - Proper scaling of the wheel to fit different screen sizes\n   - Visual indicators for section boundaries\n   - Center spin button\n3. Use the following approach for wheel rendering:\n```\nclass WheelComponent extends StatefulWidget {\n  final List<WheelSection> sections;\n  final Function(WheelSection) onSpinComplete;\n  \n  WheelComponent({required this.sections, required this.onSpinComplete});\n  \n  @override\n  _WheelComponentState createState() => _WheelComponentState();\n}\n\nclass _WheelComponentState extends State<WheelComponent> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation<double> _animation;\n  double _startRotation = 0.0;\n  double _endRotation = 0.0;\n  WheelSection? _selectedSection;\n  \n  // Implementation details for rendering and animation\n}\n```\n4. Ensure the wheel is accessible and works on various device sizes\n5. Implement proper image loading and caching for section images\n6. Add visual polish with shadows, gradients, or other design elements as appropriate",
        "testStrategy": "Test the wheel component on different screen sizes and orientations to ensure proper rendering. Verify that all sections are displayed correctly with their associated images. Test accessibility features to ensure the component is usable by all users. Perform visual inspection to confirm the wheel matches design specifications.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Wheel Spinning Animation Logic",
        "description": "Implement the animation logic for spinning the wheel, including physics-based deceleration and landing on predetermined results based on configured chances.",
        "details": "1. Create an animation controller for the wheel rotation\n2. Implement the following animation features:\n   - Initial acceleration phase\n   - Gradual deceleration to simulate physics\n   - Precise control to land on predetermined section\n   - Visual and audio feedback during spinning\n3. Develop the algorithm to select a result based on configured chances:\n```\nWheelSection selectResultBasedOnChance(List<WheelSection> sections) {\n  // Calculate total chance sum\n  double totalChance = sections.fold(0, (sum, section) => sum + section.chance);\n  \n  // Generate random value between 0 and total chance\n  double randomValue = Random().nextDouble() * totalChance;\n  \n  // Find the selected section based on cumulative chance\n  double cumulativeChance = 0;\n  for (var section in sections) {\n    cumulativeChance += section.chance;\n    if (randomValue <= cumulativeChance) {\n      return section;\n    }\n  }\n  \n  // Fallback to last section (should never happen if chances sum to total)\n  return sections.last;\n}\n```\n4. Calculate the final rotation angle to ensure the wheel lands on the selected section\n5. Add haptic feedback when the wheel stops\n6. Implement a callback to notify when spinning is complete",
        "testStrategy": "Test the spinning animation for smoothness and realistic physics. Verify that the result selection algorithm correctly respects the configured chances by running multiple spins and analyzing the distribution of results. Test edge cases like sections with zero chance or a single section with 100% chance.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Unique URL Generation System",
        "description": "Develop a system to generate unique URLs for each game instance and manage their lifecycle.",
        "details": "1. Create a URL generation service with the following features:\n   - Generate cryptographically secure random identifiers\n   - Format URLs according to the specified pattern (bonusapp://game/<unique_id>)\n   - Register new URLs in the database\n2. Implement URL validation to prevent duplicates\n3. Create a URL parser to extract game IDs from incoming URLs\n4. Add deep linking support to handle URLs opened from external sources\n5. Implement URL sharing functionality\n\nExample URL generation code:\n```\nString generateUniqueGameUrl() {\n  // Generate a secure random string (e.g., UUID v4)\n  String uniqueId = Uuid().v4();\n  \n  // Format as app URL\n  String gameUrl = 'bonusapp://game/$uniqueId';\n  \n  // Register in database\n  DatabaseHelper.insertGameInstance(uniqueId);\n  \n  return gameUrl;\n}\n```\n6. Add QR code generation for easy sharing of game URLs",
        "testStrategy": "Test URL generation for uniqueness by generating multiple URLs and verifying no duplicates. Test URL parsing with valid and invalid formats. Verify deep linking works correctly by opening URLs from various sources (browser, messaging apps, etc.). Test URL registration in the database and confirm that new game instances are properly initialized.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Game State Management",
        "description": "Implement the logic to manage game state, including tracking whether a URL has been played and storing game results.",
        "details": "1. Create a game state manager class to handle:\n   - Checking if a game URL has been played\n   - Recording game results after play\n   - Retrieving game state for display\n2. Implement the following functions:\n```\nclass GameStateManager {\n  // Check if a game has been played\n  Future<bool> isGamePlayed(String urlId) async {\n    final db = await DatabaseHelper.database();\n    final List<Map<String, dynamic>> games = await db.query(\n      'GameInstances',\n      where: 'url_id = ? AND played_at IS NOT NULL',\n      whereArgs: [urlId],\n    );\n    return games.isNotEmpty;\n  }\n  \n  // Record game result\n  Future<void> recordGameResult(String urlId, int resultId) async {\n    final db = await DatabaseHelper.database();\n    await db.update(\n      'GameInstances',\n      {\n        'played_at': DateTime.now().toIso8601String(),\n        'result_id': resultId,\n      },\n      where: 'url_id = ?',\n      whereArgs: [urlId],\n    );\n  }\n  \n  // Get game result\n  Future<Map<String, dynamic>?> getGameResult(String urlId) async {\n    final db = await DatabaseHelper.database();\n    final List<Map<String, dynamic>> results = await db.rawQuery('''\n      SELECT g.*, w.name, w.image_url \n      FROM GameInstances g\n      LEFT JOIN WheelSections w ON g.result_id = w.id\n      WHERE g.url_id = ?\n    ''', [urlId]);\n    return results.isNotEmpty ? results.first : null;\n  }\n}\n```\n3. Add synchronization mechanisms to prevent race conditions\n4. Implement caching for frequently accessed game states\n5. Add logging for game state changes",
        "testStrategy": "Create unit tests for each game state function. Test the full game lifecycle from URL generation to result storage. Verify that played games cannot be replayed. Test concurrent access to ensure thread safety. Verify that game results are correctly associated with their respective URLs.",
        "priority": "high",
        "dependencies": [
          2,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Main Game Screen Implementation",
        "description": "Develop the main game screen that displays the wheel, handles user interaction, and shows game results.",
        "details": "1. Create the main game screen with the following components:\n   - Wheel component (from Task 4)\n   - Spin button\n   - Result display area\n   - Background and branding elements\n2. Implement the screen logic:\n```\nclass GameScreen extends StatefulWidget {\n  final String gameUrlId;\n  \n  GameScreen({required this.gameUrlId});\n  \n  @override\n  _GameScreenState createState() => _GameScreenState();\n}\n\nclass _GameScreenState extends State<GameScreen> {\n  bool _isLoading = true;\n  bool _hasBeenPlayed = false;\n  List<WheelSection> _wheelSections = [];\n  WheelSection? _gameResult;\n  \n  @override\n  void initState() {\n    super.initState();\n    _loadGameState();\n  }\n  \n  Future<void> _loadGameState() async {\n    // Load wheel configuration\n    _wheelSections = await ConfigParser.getWheelSections();\n    \n    // Check if game has been played\n    _hasBeenPlayed = await GameStateManager().isGamePlayed(widget.gameUrlId);\n    \n    // If played, load the result\n    if (_hasBeenPlayed) {\n      final result = await GameStateManager().getGameResult(widget.gameUrlId);\n      // Parse result into WheelSection\n    }\n    \n    setState(() {\n      _isLoading = false;\n    });\n  }\n  \n  void _handleSpin() {\n    // Logic for handling spin button press\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    // UI implementation\n  }\n}\n```\n3. Handle different states:\n   - Loading state\n   - Fresh game state (with spin button)\n   - Played game state (showing result)\n4. Implement transitions between states\n5. Add visual feedback for user actions\n6. Ensure the UI is responsive and works on different screen sizes",
        "testStrategy": "Test the game screen on different devices and orientations. Verify all states (loading, fresh game, played game) display correctly. Test user interactions like pressing the spin button. Verify that game results are displayed correctly after spinning. Test edge cases like network interruptions or database errors.",
        "priority": "high",
        "dependencies": [
          4,
          5,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Administrator Interface",
        "description": "Create an administrative interface for generating new game URLs and managing wheel configurations.",
        "details": "1. Develop an admin screen with the following features:\n   - URL generation button\n   - Display area for generated URLs\n   - Copy URL button\n   - Configuration reload option\n2. Implement access control for the admin interface (e.g., hidden gesture or password protection)\n3. Create a URL list view showing recently generated URLs\n4. Add functionality to export generated URLs (e.g., as CSV)\n5. Implement a simple configuration editor for the wheel sections\n\nExample admin screen implementation:\n```\nclass AdminScreen extends StatefulWidget {\n  @override\n  _AdminScreenState createState() => _AdminScreenState();\n}\n\nclass _AdminScreenState extends State<AdminScreen> {\n  List<String> _generatedUrls = [];\n  \n  void _generateNewUrl() async {\n    final url = await UrlGenerator.generateUniqueGameUrl();\n    setState(() {\n      _generatedUrls.insert(0, url);\n    });\n  }\n  \n  void _copyUrlToClipboard(String url) {\n    Clipboard.setData(ClipboardData(text: url));\n    // Show confirmation\n  }\n  \n  void _reloadConfiguration() async {\n    await ConfigParser.reloadConfiguration();\n    // Show confirmation\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    // UI implementation\n  }\n}\n```\n6. Add analytics for URL usage and game results",
        "testStrategy": "Test URL generation functionality and verify that generated URLs are valid and unique. Test the copy to clipboard feature. Verify that configuration reload works correctly. Test access control to ensure the admin interface is not easily accessible to regular users. Verify that generated URLs are properly registered in the database.",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Result Display Screen",
        "description": "Implement the screen that displays game results for played URLs, ensuring consistent display on revisits.",
        "details": "1. Create a result display screen with the following features:\n   - Clear visualization of the winning wheel section\n   - Display of section image and name\n   - Timestamp of when the game was played\n   - Share result button\n2. Implement animations for revealing the result\n3. Add confetti or other visual effects for positive results\n4. Create a layout that works well for sharing (e.g., screenshot-friendly)\n\nExample implementation:\n```\nclass ResultScreen extends StatelessWidget {\n  final WheelSection result;\n  final DateTime playedAt;\n  \n  ResultScreen({required this.result, required this.playedAt});\n  \n  void _shareResult() {\n    // Implementation for sharing result\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Your Result', style: TextStyle(fontSize: 24)),\n            SizedBox(height: 20),\n            Image.asset(result.imageUrl, width: 200, height: 200),\n            SizedBox(height: 10),\n            Text(result.name, style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold)),\n            SizedBox(height: 20),\n            Text('Played on ${DateFormat.yMMMd().add_jm().format(playedAt)}'),\n            SizedBox(height: 30),\n            ElevatedButton(\n              onPressed: _shareResult,\n              child: Text('Share Result'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n5. Implement deep linking to allow direct access to result screens\n6. Add animation transitions between game screen and result screen",
        "testStrategy": "Test the result display with various wheel section configurations. Verify that all result information (image, name, timestamp) is displayed correctly. Test the share functionality. Verify that revisiting a played URL consistently shows the same result. Test deep linking to result screens.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "URL Handling and Navigation System",
        "description": "Implement the system to handle app navigation and URL routing, ensuring proper handling of deep links and game URLs.",
        "details": "1. Set up a navigation system with the following routes:\n   - Home/landing screen\n   - Game screen (with URL parameter)\n   - Result screen (with URL parameter)\n   - Admin screen\n2. Implement deep link handling for 'bonusapp://game/<unique_id>' format\n3. Create URL interceptors to process incoming links\n4. Add navigation guards to prevent access to played games\n5. Implement history management for back button behavior\n\nExample navigation setup:\n```\nclass AppRouter {\n  static Route<dynamic> generateRoute(RouteSettings settings) {\n    switch (settings.name) {\n      case '/':\n        return MaterialPageRoute(builder: (_) => HomeScreen());\n      case '/game':\n        final args = settings.arguments as Map<String, dynamic>;\n        return MaterialPageRoute(\n          builder: (_) => GameScreen(gameUrlId: args['urlId']),\n        );\n      case '/admin':\n        return MaterialPageRoute(builder: (_) => AdminScreen());\n      default:\n        // Handle deep links or unknown routes\n        final uri = Uri.parse(settings.name ?? '');\n        if (uri.path.startsWith('/game/')) {\n          final urlId = uri.pathSegments[1];\n          return MaterialPageRoute(\n            builder: (_) => GameScreen(gameUrlId: urlId),\n          );\n        }\n        return MaterialPageRoute(builder: (_) => NotFoundScreen());\n    }\n  }\n}\n```\n6. Add URL validation to prevent manipulation\n7. Implement proper error handling for invalid URLs",
        "testStrategy": "Test navigation between all screens. Verify deep linking works correctly by opening the app with various URLs. Test URL validation with valid and invalid formats. Verify that navigation guards prevent access to played games. Test back button behavior and history management.",
        "priority": "medium",
        "dependencies": [
          6,
          8,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Offline Functionality Implementation",
        "description": "Ensure the app functions properly without an internet connection, including game play and result display.",
        "details": "1. Implement offline detection:\n```\nFuture<bool> checkConnectivity() async {\n  var connectivityResult = await Connectivity().checkConnectivity();\n  return connectivityResult != ConnectivityResult.none;\n}\n```\n2. Create a local cache for all necessary assets:\n   - Wheel section images\n   - Configuration data\n   - Previously generated URLs\n3. Implement graceful degradation for features that require connectivity\n4. Add synchronization for when connectivity is restored\n5. Create offline indicators in the UI when relevant\n6. Ensure all core gameplay functions work without internet\n7. Implement local storage for game results",
        "testStrategy": "Test the app in airplane mode to verify all core functionality works offline. Test transitions between online and offline states. Verify that all assets are properly cached and accessible offline. Test edge cases like the app starting in offline mode or losing connectivity during critical operations.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "UI Polish and Animations",
        "description": "Enhance the user interface with polished visuals, smooth animations, and engaging feedback to create a premium feel.",
        "details": "1. Implement the following animations:\n   - App startup animation\n   - Screen transitions\n   - Button press effects\n   - Result reveal animations\n2. Add sound effects for:\n   - Wheel spinning\n   - Result reveal\n   - Button presses\n3. Implement haptic feedback for key interactions\n4. Create custom button and UI component styles\n5. Add particle effects or confetti for winning results\n6. Optimize animations for performance\n7. Ensure consistent branding throughout the app\n8. Implement dark/light mode support if appropriate",
        "testStrategy": "Test animations for smoothness and performance on various devices. Verify sound effects play correctly and at appropriate volumes. Test haptic feedback on supported devices. Verify UI consistency across the app. Test performance impact of animations and effects to ensure they don't cause lag or battery drain.",
        "priority": "low",
        "dependencies": [
          4,
          8,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Testing and Quality Assurance",
        "description": "Implement comprehensive testing to ensure the app functions correctly across different devices and scenarios.",
        "details": "1. Create unit tests for core functionality:\n   - Database operations\n   - URL generation and validation\n   - Game state management\n   - Wheel section selection algorithm\n2. Implement integration tests for key user flows:\n   - Complete game play cycle\n   - URL generation and access\n   - Configuration loading\n3. Perform UI tests for all screens\n4. Create performance tests for animations and database operations\n5. Test on multiple device sizes and OS versions\n6. Implement crash reporting and analytics\n7. Create a test plan document with test cases and expected results\n8. Perform security testing for URL validation",
        "testStrategy": "Execute all test cases and verify they pass. Perform manual testing on various devices and OS versions. Test edge cases and error scenarios. Verify crash reporting works correctly. Conduct performance testing under various conditions (low battery, low storage, etc.).",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "App Deployment and Distribution",
        "description": "Prepare the app for deployment to app stores and create distribution mechanisms for administrators.",
        "details": "1. Configure app signing for both platforms:\n   - Generate signing keys\n   - Set up signing configuration\n2. Create app store listings:\n   - Write app descriptions\n   - Create screenshots and promotional images\n   - Prepare privacy policy\n3. Implement versioning and update mechanism\n4. Create distribution profiles for testing\n5. Configure analytics and crash reporting services\n6. Prepare documentation for administrators\n7. Create a simple website or landing page for the app\n8. Set up CI/CD pipeline for automated builds",
        "testStrategy": "Test the signed app builds on real devices. Verify that app store submissions meet all requirements. Test the update mechanism. Verify analytics and crash reporting work correctly in production builds. Conduct a final review of all documentation for accuracy.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-01T16:07:44.495Z",
      "updated": "2025-08-01T16:07:44.495Z",
      "description": "Tasks for master context"
    }
  }
}