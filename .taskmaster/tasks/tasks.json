{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Configuration",
        "description": "Initialize the Next.js project with TypeScript, TailwindCSS, and SQLite dependencies as specified in the PRD.",
        "details": "1. Create a new Next.js project with TypeScript:\n```bash\nnpx create-next-app@latest --typescript bonus-app\ncd bonus-app\n```\n2. Install required dependencies:\n```bash\nnpm install tailwindcss postcss autoprefixer sqlite3 uuid\nnpx tailwindcss init -p\n```\n3. Configure TailwindCSS in tailwind.config.js and globals.css\n4. Set up project structure with directories for:\n   - components/\n   - pages/\n   - public/images/\n   - config/\n   - lib/ (for database utilities)\n5. Create initial config/wheel.json file with example configuration",
        "testStrategy": "Verify all dependencies are correctly installed by running `npm list`. Ensure the project builds without errors using `npm run build`. Check that TailwindCSS is properly configured by testing a simple component with Tailwind classes.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Database Schema and SQLite Integration",
        "description": "Set up SQLite database with the required schema for storing game sessions and results.",
        "details": "1. Create a lib/db.ts file for database utilities\n2. Implement database initialization function:\n```typescript\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n\nexport async function openDb() {\n  return open({\n    filename: './database.sql',\n    driver: sqlite3.Database\n  });\n}\n\nexport async function initDb() {\n  const db = await openDb();\n  await db.exec(`\n    CREATE TABLE IF NOT EXISTS games (\n      id TEXT PRIMARY KEY,\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      played BOOLEAN DEFAULT 0,\n      result_label TEXT,\n      result_image TEXT\n    );\n  `);\n  return db;\n}\n```\n3. Create database utility functions for:\n   - Creating a new game entry\n   - Retrieving game by ID\n   - Updating game with result\n4. Ensure database file persists between server restarts",
        "testStrategy": "Write unit tests for database functions using Jest. Test creating, retrieving, and updating game entries. Verify the database schema matches the PRD requirements. Test database persistence by restarting the server and checking if data remains.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Wheel Configuration JSON Loader",
        "description": "Create a utility to load and validate the wheel configuration from the JSON file.",
        "details": "1. Create a lib/wheelConfig.ts file\n2. Define TypeScript interfaces for wheel configuration:\n```typescript\nexport interface WheelSegment {\n  label: string;\n  image: string;\n  chance: number;\n}\n\nexport interface WheelConfig extends Array<WheelSegment> {}\n```\n3. Implement function to load and validate wheel configuration:\n```typescript\nimport fs from 'fs';\nimport path from 'path';\n\nexport async function loadWheelConfig(): Promise<WheelConfig> {\n  const configPath = path.join(process.cwd(), 'config', 'wheel.json');\n  const configData = await fs.promises.readFile(configPath, 'utf8');\n  const config: WheelConfig = JSON.parse(configData);\n  \n  // Validate config\n  if (!Array.isArray(config) || config.length < 2) {\n    throw new Error('Invalid wheel configuration: must be an array with at least 2 segments');\n  }\n  \n  // Validate total chance adds up to approximately 1\n  const totalChance = config.reduce((sum, segment) => sum + segment.chance, 0);\n  if (Math.abs(totalChance - 1) > 0.001) {\n    throw new Error(`Invalid wheel configuration: chances must sum to 1, got ${totalChance}`);\n  }\n  \n  return config;\n}\n```\n4. Create a sample wheel.json in the config directory with the example from the PRD",
        "testStrategy": "Write unit tests to verify the wheel configuration loader correctly loads and validates JSON. Test with valid configurations and various invalid configurations (missing fields, chances not adding up to 1, etc.). Ensure the loader throws appropriate errors for invalid configurations.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Game URL Generator API Endpoint",
        "description": "Create an API endpoint to generate unique game URLs and store them in the database.",
        "details": "1. Create pages/api/games/create.ts file\n2. Implement API endpoint to generate a unique game ID:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { v4 as uuidv4 } from 'uuid';\nimport { openDb } from '../../../lib/db';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const gameId = uuidv4();\n    const db = await openDb();\n    \n    await db.run(\n      'INSERT INTO games (id, played) VALUES (?, ?)',\n      [gameId, 0]\n    );\n    \n    return res.status(200).json({ \n      gameId, \n      url: `/game/${gameId}` \n    });\n  } catch (error) {\n    console.error('Error creating game:', error);\n    return res.status(500).json({ error: 'Failed to create game' });\n  }\n}\n```\n3. Ensure the endpoint returns a properly formatted URL that can be used to access the game",
        "testStrategy": "Test the API endpoint using tools like Postman or Jest with supertest. Verify that a unique ID is generated each time. Check that the database entry is created correctly with played=false. Ensure the returned URL format matches the requirements.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Game State API Endpoint",
        "description": "Create an API endpoint to retrieve and update game state.",
        "details": "1. Create pages/api/games/[id].ts file\n2. Implement GET endpoint to retrieve game state:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { openDb } from '../../../lib/db';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { id } = req.query;\n  \n  if (typeof id !== 'string') {\n    return res.status(400).json({ error: 'Invalid game ID' });\n  }\n\n  const db = await openDb();\n  \n  if (req.method === 'GET') {\n    try {\n      const game = await db.get('SELECT * FROM games WHERE id = ?', id);\n      \n      if (!game) {\n        return res.status(404).json({ error: 'Game not found' });\n      }\n      \n      return res.status(200).json(game);\n    } catch (error) {\n      console.error('Error retrieving game:', error);\n      return res.status(500).json({ error: 'Failed to retrieve game' });\n    }\n  } else if (req.method === 'PUT') {\n    try {\n      const { result_label, result_image } = req.body;\n      \n      if (!result_label || !result_image) {\n        return res.status(400).json({ error: 'Missing result data' });\n      }\n      \n      const game = await db.get('SELECT * FROM games WHERE id = ?', id);\n      \n      if (!game) {\n        return res.status(404).json({ error: 'Game not found' });\n      }\n      \n      if (game.played) {\n        return res.status(400).json({ error: 'Game already played' });\n      }\n      \n      await db.run(\n        'UPDATE games SET played = 1, result_label = ?, result_image = ? WHERE id = ?',\n        [result_label, result_image, id]\n      );\n      \n      return res.status(200).json({ success: true });\n    } catch (error) {\n      console.error('Error updating game:', error);\n      return res.status(500).json({ error: 'Failed to update game' });\n    }\n  }\n  \n  return res.status(405).json({ error: 'Method not allowed' });\n}\n```",
        "testStrategy": "Test both GET and PUT endpoints. For GET, verify correct game data is returned and 404 for non-existent games. For PUT, test updating game results and verify the played flag is set correctly. Test error cases like trying to update an already played game.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Wheel Component Implementation",
        "description": "Create a reusable wheel component that can be configured with segments and handles spinning animation.",
        "details": "1. Create components/Wheel.tsx\n2. Implement the wheel component with configurable segments:\n```typescript\nimport React, { useState, useRef, useEffect } from 'react';\nimport Image from 'next/image';\nimport { WheelSegment } from '../lib/wheelConfig';\n\ninterface WheelProps {\n  segments: WheelSegment[];\n  onSpinComplete: (segment: WheelSegment) => void;\n  disabled?: boolean;\n  selectedSegment?: WheelSegment;\n}\n\nconst Wheel: React.FC<WheelProps> = ({ \n  segments, \n  onSpinComplete, \n  disabled = false,\n  selectedSegment = null\n}) => {\n  const [rotation, setRotation] = useState(0);\n  const [spinning, setSpinning] = useState(false);\n  const wheelRef = useRef<HTMLDivElement>(null);\n  \n  const segmentAngle = 360 / segments.length;\n  \n  const handleSpin = () => {\n    if (disabled || spinning || selectedSegment) return;\n    \n    setSpinning(true);\n    \n    // Calculate final rotation to land on the selected segment\n    const segmentIndex = segments.indexOf(selectedSegment);\n    const segmentPosition = 360 - (segmentIndex * segmentAngle);\n    \n    // Add extra rotations for effect (5-10 full rotations)\n    const extraRotations = 5 + Math.floor(Math.random() * 5);\n    const finalRotation = rotation + (360 * extraRotations) + segmentPosition;\n    \n    // Animate the spin\n    setRotation(finalRotation);\n    \n    // Call onSpinComplete after animation ends\n    setTimeout(() => {\n      setSpinning(false);\n      onSpinComplete(selectedSegment);\n    }, 5000); // Match this with CSS animation duration\n  };\n  \n  return (\n    <div className=\"relative w-full max-w-md mx-auto aspect-square\">\n      <div \n        ref={wheelRef}\n        className={`wheel-container w-full h-full rounded-full overflow-hidden transition-transform duration-5000 ease-out`}\n        style={{ transform: `rotate(${rotation}deg)` }}\n      >\n        {segments.map((segment, index) => {\n          const startAngle = index * segmentAngle;\n          return (\n            <div \n              key={index}\n              className=\"absolute top-0 left-0 w-1/2 h-1/2 origin-bottom-right\"\n              style={{ transform: `rotate(${startAngle}deg)` }}\n            >\n              <div className=\"w-full h-full overflow-hidden\">\n                <div className=\"relative w-full h-full\">\n                  <Image \n                    src={segment.image} \n                    alt={segment.label}\n                    layout=\"fill\"\n                    objectFit=\"cover\"\n                  />\n                  <div className=\"absolute bottom-0 left-0 w-full text-center text-white bg-black bg-opacity-50 p-1\">\n                    {segment.label}\n                  </div>\n                </div>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n      \n      <button\n        className={`absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-600 text-white font-bold py-4 px-6 rounded-full z-10 ${(disabled || spinning || selectedSegment) ? 'opacity-50 cursor-not-allowed' : 'hover:bg-red-700'}`}\n        onClick={handleSpin}\n        disabled={disabled || spinning || !!selectedSegment}\n      >\n        SPIN\n      </button>\n    </div>\n  );\n};\n\nexport default Wheel;\n```\n3. Add CSS for wheel animation in globals.css:\n```css\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(var(--final-rotation)); }\n}\n\n.wheel-container {\n  transition: transform 5s cubic-bezier(0.17, 0.67, 0.12, 0.99);\n}\n```",
        "testStrategy": "Create a test component that renders the Wheel with sample configuration. Test the wheel rendering with different numbers of segments. Verify the spin animation works correctly and calls onSpinComplete with the correct segment. Test disabled state prevents spinning.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Game Result Selection Logic",
        "description": "Implement the weighted random selection logic to determine game results based on segment chances.",
        "details": "1. Create lib/gameLogic.ts file\n2. Implement weighted random selection function:\n```typescript\nimport { WheelSegment } from './wheelConfig';\n\nexport function selectRandomSegment(segments: WheelSegment[]): WheelSegment {\n  // Validate segments\n  if (!segments || segments.length === 0) {\n    throw new Error('No segments provided');\n  }\n  \n  // Generate random number between 0 and 1\n  const random = Math.random();\n  \n  // Use cumulative probability to select segment\n  let cumulativeProbability = 0;\n  \n  for (const segment of segments) {\n    cumulativeProbability += segment.chance;\n    \n    if (random <= cumulativeProbability) {\n      return segment;\n    }\n  }\n  \n  // Fallback to last segment (should rarely happen due to floating point precision)\n  return segments[segments.length - 1];\n}\n```\n3. Add function to validate that chances sum to 1:\n```typescript\nexport function validateSegmentChances(segments: WheelSegment[]): boolean {\n  const sum = segments.reduce((total, segment) => total + segment.chance, 0);\n  return Math.abs(sum - 1) < 0.001; // Allow small floating point error\n}\n```",
        "testStrategy": "Write unit tests for the selectRandomSegment function. Test with various segment configurations. Run the function multiple times (e.g., 10,000 iterations) and verify the distribution of results matches the configured chances. Test edge cases like segments with 0 chance or a single segment with 100% chance.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Home Page with URL Generator",
        "description": "Create the home page with the 'Generate Game Link' button and functionality.",
        "details": "1. Create/modify pages/index.tsx\n2. Implement home page with URL generator:\n```typescript\nimport { useState } from 'react';\nimport Head from 'next/head';\n\nexport default function Home() {\n  const [gameUrl, setGameUrl] = useState<string | null>(null);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [copySuccess, setCopySuccess] = useState(false);\n\n  const generateGameLink = async () => {\n    setIsGenerating(true);\n    try {\n      const response = await fetch('/api/games/create', {\n        method: 'POST',\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to generate game link');\n      }\n      \n      const data = await response.json();\n      const fullUrl = `${window.location.origin}${data.url}`;\n      setGameUrl(fullUrl);\n    } catch (error) {\n      console.error('Error generating game link:', error);\n      alert('Failed to generate game link. Please try again.');\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const copyToClipboard = async () => {\n    if (!gameUrl) return;\n    \n    try {\n      await navigator.clipboard.writeText(gameUrl);\n      setCopySuccess(true);\n      setTimeout(() => setCopySuccess(false), 2000);\n    } catch (error) {\n      console.error('Failed to copy:', error);\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen flex flex-col items-center justify-center p-4 bg-gray-100\">\n      <Head>\n        <title>Bonus App - Spin the Wheel!</title>\n        <meta name=\"description\" content=\"Spin the wheel and win rewards\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n\n      <main className=\"w-full max-w-md mx-auto bg-white rounded-lg shadow-md p-6\">\n        <h1 className=\"text-3xl font-bold text-center mb-6\">Bonus App</h1>\n        \n        <p className=\"text-gray-600 mb-8 text-center\">\n          Generate a unique game link to share with others. Each link can only be played once!\n        </p>\n        \n        <button\n          onClick={generateGameLink}\n          disabled={isGenerating}\n          className=\"w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg mb-6 disabled:opacity-50\"\n        >\n          {isGenerating ? 'Generating...' : 'Generate Game Link'}\n        </button>\n        \n        {gameUrl && (\n          <div className=\"mt-4\">\n            <div className=\"flex items-center\">\n              <input\n                type=\"text\"\n                value={gameUrl}\n                readOnly\n                className=\"flex-grow p-2 border rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500\"\n              />\n              <button\n                onClick={copyToClipboard}\n                className=\"bg-gray-200 hover:bg-gray-300 px-4 py-2 rounded-r-lg\"\n              >\n                {copySuccess ? 'Copied!' : 'Copy'}\n              </button>\n            </div>\n            <p className=\"mt-2 text-sm text-gray-500\">\n              Share this link with someone to let them play the game. The link can only be used once.\n            </p>\n          </div>\n        )}\n      </main>\n    </div>\n  );\n}\n```",
        "testStrategy": "Test the home page rendering. Verify the 'Generate Game Link' button calls the API correctly. Test the copy to clipboard functionality. Check that the UI updates appropriately during loading states and after successful generation.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Game Page Implementation",
        "description": "Create the game page that loads game state and displays either the wheel or the result.",
        "details": "1. Create pages/game/[id].tsx\n2. Implement the game page with different states (playable or already played):\n```typescript\nimport { useState, useEffect } from 'react';\nimport { useRouter } from 'next/router';\nimport Head from 'next/head';\nimport Image from 'next/image';\nimport Wheel from '../../components/Wheel';\nimport { loadWheelConfig, WheelSegment } from '../../lib/wheelConfig';\nimport { selectRandomSegment } from '../../lib/gameLogic';\n\nexport default function GamePage() {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [game, setGame] = useState<any>(null);\n  const [wheelConfig, setWheelConfig] = useState<WheelSegment[]>([]);\n  const [selectedSegment, setSelectedSegment] = useState<WheelSegment | null>(null);\n  const [spinComplete, setSpinComplete] = useState(false);\n  \n  // Load game data and wheel config\n  useEffect(() => {\n    if (!id) return;\n    \n    const fetchData = async () => {\n      try {\n        // Load wheel configuration\n        const config = await fetch('/api/wheel-config').then(res => res.json());\n        setWheelConfig(config);\n        \n        // Load game state\n        const gameResponse = await fetch(`/api/games/${id}`);\n        \n        if (!gameResponse.ok) {\n          if (gameResponse.status === 404) {\n            setError('Game not found');\n          } else {\n            setError('Failed to load game');\n          }\n          setLoading(false);\n          return;\n        }\n        \n        const gameData = await gameResponse.json();\n        setGame(gameData);\n        \n        // If game already played, set the result\n        if (gameData.played) {\n          const playedSegment = config.find(s => s.label === gameData.result_label);\n          if (playedSegment) {\n            setSelectedSegment(playedSegment);\n            setSpinComplete(true);\n          }\n        } else {\n          // Pre-determine the result for new game\n          const result = selectRandomSegment(config);\n          setSelectedSegment(result);\n        }\n        \n        setLoading(false);\n      } catch (err) {\n        console.error('Error loading game:', err);\n        setError('Failed to load game data');\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, [id]);\n  \n  const handleSpinComplete = async (segment: WheelSegment) => {\n    setSpinComplete(true);\n    \n    // Save result to database\n    try {\n      await fetch(`/api/games/${id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          result_label: segment.label,\n          result_image: segment.image,\n        }),\n      });\n      \n      // Update local game state\n      setGame(prev => ({\n        ...prev,\n        played: true,\n        result_label: segment.label,\n        result_image: segment.image,\n      }));\n    } catch (err) {\n      console.error('Error saving game result:', err);\n    }\n  };\n  \n  if (loading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <p className=\"text-xl\">Loading game...</p>\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <div className=\"text-center\">\n          <p className=\"text-xl text-red-600 mb-4\">{error}</p>\n          <button\n            onClick={() => router.push('/')}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n          >\n            Back to Home\n          </button>\n        </div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"min-h-screen flex flex-col items-center justify-center p-4\">\n      <Head>\n        <title>Bonus App - Spin the Wheel!</title>\n        <meta name=\"description\" content=\"Spin the wheel and win rewards\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n      \n      <main className=\"w-full max-w-md mx-auto\">\n        <h1 className=\"text-3xl font-bold text-center mb-6\">Bonus Wheel</h1>\n        \n        {game.played && spinComplete ? (\n          <div className=\"text-center\">\n            <div className=\"mb-6\">\n              <div className=\"relative w-48 h-48 mx-auto mb-4\">\n                <Image \n                  src={game.result_image} \n                  alt={game.result_label}\n                  layout=\"fill\"\n                  objectFit=\"contain\"\n                />\n              </div>\n              <h2 className=\"text-2xl font-bold mb-2\">Your Result:</h2>\n              <p className=\"text-xl\">{game.result_label}</p>\n            </div>\n            <button\n              onClick={() => router.push('/')}\n              className=\"bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n            >\n              Back to Home\n            </button>\n          </div>\n        ) : (\n          <Wheel \n            segments={wheelConfig}\n            onSpinComplete={handleSpinComplete}\n            disabled={game.played}\n            selectedSegment={selectedSegment}\n          />\n        )}\n      </main>\n    </div>\n  );\n}\n```\n3. Create API endpoint for wheel configuration at pages/api/wheel-config.ts:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { loadWheelConfig } from '../../lib/wheelConfig';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const config = await loadWheelConfig();\n    return res.status(200).json(config);\n  } catch (error) {\n    console.error('Error loading wheel config:', error);\n    return res.status(500).json({ error: 'Failed to load wheel configuration' });\n  }\n}\n```",
        "testStrategy": "Test the game page with both new and already played game IDs. Verify the wheel is shown for new games and the result is shown for played games. Test the spin functionality and ensure the result is saved correctly. Test error handling for invalid game IDs.",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Wheel Animation and Visual Effects",
        "description": "Enhance the wheel component with smooth animations and visual effects for a better user experience.",
        "details": "1. Update the Wheel component with improved animations:\n```typescript\n// Add to components/Wheel.tsx\n\n// Update the handleSpin function\nconst handleSpin = () => {\n  if (disabled || spinning || !selectedSegment) return;\n  \n  setSpinning(true);\n  \n  // Calculate final rotation to land on the selected segment\n  const segmentIndex = segments.findIndex(s => \n    s.label === selectedSegment.label && s.image === selectedSegment.image\n  );\n  \n  if (segmentIndex === -1) {\n    console.error('Selected segment not found in segments array');\n    setSpinning(false);\n    return;\n  }\n  \n  // Calculate the angle to the middle of the segment\n  const segmentMiddleAngle = segmentIndex * segmentAngle + (segmentAngle / 2);\n  \n  // The wheel needs to rotate so that the segment is at the top (270 degrees)\n  const segmentPosition = 270 - segmentMiddleAngle;\n  \n  // Add extra rotations for effect (5-10 full rotations)\n  const extraRotations = 5 + Math.floor(Math.random() * 5);\n  const finalRotation = rotation + (360 * extraRotations) + segmentPosition;\n  \n  // Animate the spin with easing\n  setRotation(finalRotation);\n  \n  // Call onSpinComplete after animation ends\n  setTimeout(() => {\n    setSpinning(false);\n    onSpinComplete(selectedSegment);\n  }, 5000); // Match this with CSS animation duration\n};\n```\n2. Add CSS for improved wheel animation in globals.css:\n```css\n.wheel-container {\n  transition: transform 5s cubic-bezier(0.17, 0.67, 0.12, 0.99);\n  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);\n  border: 10px solid #f3f4f6;\n}\n\n.wheel-segment {\n  transition: all 0.3s ease;\n}\n\n.wheel-segment:hover {\n  filter: brightness(1.1);\n}\n\n.spin-button {\n  transition: all 0.3s ease;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n}\n\n.spin-button:hover:not(:disabled) {\n  transform: scale(1.05);\n  box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);\n}\n\n.spin-button:active:not(:disabled) {\n  transform: scale(0.95);\n}\n```\n3. Add a pointer/indicator at the top of the wheel to show where the wheel will stop:\n```tsx\n// Add this to the Wheel component JSX\n<div className=\"absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10\">\n  <div className=\"w-0 h-0 border-l-[20px] border-r-[20px] border-t-[30px] border-l-transparent border-r-transparent border-t-red-600\"></div>\n</div>\n```",
        "testStrategy": "Test the wheel animation visually in different browsers. Verify the wheel stops at the correct position for the selected segment. Test the animation timing and easing. Check that the pointer/indicator correctly shows where the wheel will stop.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Mobile Responsiveness",
        "description": "Ensure the application is fully responsive and works well on mobile devices.",
        "details": "1. Update layout components to be mobile-first:\n```typescript\n// Add viewport meta tag in pages/_document.tsx\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\n\nclass MyDocument extends Document {\n  render() {\n    return (\n      <Html>\n        <Head>\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n\nexport default MyDocument;\n```\n2. Update the Wheel component for better mobile experience:\n```typescript\n// In components/Wheel.tsx\n\n// Update the container div\n<div className=\"relative w-full max-w-md mx-auto aspect-square touch-none\">\n  {/* ... */}\n</div>\n\n// Make the spin button larger on mobile\n<button\n  className={`absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-600 text-white font-bold py-4 px-6 rounded-full z-10 spin-button ${(disabled || spinning || !!selectedSegment) ? 'opacity-50 cursor-not-allowed' : 'hover:bg-red-700'} sm:py-6 sm:px-8 sm:text-lg`}\n  onClick={handleSpin}\n  disabled={disabled || spinning || !!selectedSegment}\n>\n  SPIN\n</button>\n```\n3. Add responsive styles to the game page:\n```typescript\n// In pages/game/[id].tsx\n\n// Update the main container\n<main className=\"w-full max-w-md mx-auto px-4 sm:px-0\">\n  {/* ... */}\n</main>\n\n// Make result display responsive\n<div className=\"relative w-48 h-48 mx-auto mb-4 sm:w-64 sm:h-64\">\n  {/* ... */}\n</div>\n```\n4. Test on various device sizes and orientations",
        "testStrategy": "Test the application on various device sizes using browser dev tools. Verify the wheel and buttons are appropriately sized on mobile. Test touch interactions for spinning the wheel. Ensure the game is playable on both portrait and landscape orientations.",
        "priority": "high",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Error Handling and Edge Cases",
        "description": "Implement comprehensive error handling and manage edge cases throughout the application.",
        "details": "1. Create a components/ErrorMessage.tsx component:\n```typescript\nimport React from 'react';\n\ninterface ErrorMessageProps {\n  message: string;\n  onRetry?: () => void;\n}\n\nconst ErrorMessage: React.FC<ErrorMessageProps> = ({ message, onRetry }) => {\n  return (\n    <div className=\"bg-red-50 border-l-4 border-red-500 p-4 my-4\">\n      <div className=\"flex items-start\">\n        <div className=\"flex-shrink-0\">\n          <svg className=\"h-5 w-5 text-red-500\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\" clipRule=\"evenodd\" />\n          </svg>\n        </div>\n        <div className=\"ml-3\">\n          <p className=\"text-sm text-red-700\">{message}</p>\n          {onRetry && (\n            <button \n              onClick={onRetry}\n              className=\"mt-2 text-sm text-red-700 underline hover:text-red-900\"\n            >\n              Try again\n            </button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ErrorMessage;\n```\n2. Handle database connection errors:\n```typescript\n// In lib/db.ts\n\nexport async function openDb() {\n  try {\n    return await open({\n      filename: './database.sql',\n      driver: sqlite3.Database\n    });\n  } catch (error) {\n    console.error('Database connection error:', error);\n    throw new Error('Failed to connect to database');\n  }\n}\n```\n3. Add error boundaries to catch rendering errors:\n```typescript\n// In pages/_app.tsx\nimport { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error?: Error;\n}\n\nclass ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      return (\n        <div className=\"min-h-screen flex items-center justify-center p-4\">\n          <div className=\"text-center\">\n            <h1 className=\"text-2xl font-bold text-red-600 mb-4\">Something went wrong</h1>\n            <p className=\"mb-4\">{this.state.error?.message || 'An unexpected error occurred'}</p>\n            <button\n              onClick={() => this.setState({ hasError: false })}\n              className=\"bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n            >\n              Try again\n            </button>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <ErrorBoundary>\n      <Component {...pageProps} />\n    </ErrorBoundary>\n  );\n}\n\nexport default MyApp;\n```\n4. Handle edge cases like invalid wheel configuration:\n```typescript\n// In lib/wheelConfig.ts\n\nexport async function loadWheelConfig(): Promise<WheelConfig> {\n  try {\n    const configPath = path.join(process.cwd(), 'config', 'wheel.json');\n    const configData = await fs.promises.readFile(configPath, 'utf8');\n    const config: WheelConfig = JSON.parse(configData);\n    \n    // Validate config\n    if (!Array.isArray(config) || config.length < 2) {\n      throw new Error('Invalid wheel configuration: must be an array with at least 2 segments');\n    }\n    \n    // Validate total chance adds up to approximately 1\n    const totalChance = config.reduce((sum, segment) => sum + segment.chance, 0);\n    if (Math.abs(totalChance - 1) > 0.001) {\n      console.warn(`Warning: Wheel segment chances sum to ${totalChance}, not 1. This may cause unexpected behavior.`);\n    }\n    \n    // Validate each segment has required properties\n    for (const segment of config) {\n      if (!segment.label || !segment.image || typeof segment.chance !== 'number') {\n        throw new Error('Invalid wheel segment: each segment must have label, image, and chance properties');\n      }\n    }\n    \n    return config;\n  } catch (error) {\n    console.error('Error loading wheel config:', error);\n    // Provide a fallback configuration\n    return [\n      { label: 'Bonus 10%', image: '/images/fallback-bonus.png', chance: 0.1 },\n      { label: 'No Bonus', image: '/images/fallback-nobonus.png', chance: 0.9 }\n    ];\n  }\n}\n```",
        "testStrategy": "Test error handling by intentionally causing errors (invalid game IDs, malformed wheel configuration, database connection issues). Verify that appropriate error messages are displayed. Test the error boundary by causing rendering errors. Ensure the application gracefully handles all error conditions.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Sample Wheel Configuration and Images",
        "description": "Create sample wheel configuration and placeholder images for testing and demonstration.",
        "details": "1. Create a sample wheel.json in the config directory:\n```json\n[\n  {\n    \"label\": \"Bonus 10%\",\n    \"image\": \"/images/bonus10.png\",\n    \"chance\": 0.1\n  },\n  {\n    \"label\": \"Bonus 20%\",\n    \"image\": \"/images/bonus20.png\",\n    \"chance\": 0.05\n  },\n  {\n    \"label\": \"Bonus 5%\",\n    \"image\": \"/images/bonus5.png\",\n    \"chance\": 0.15\n  },\n  {\n    \"label\": \"Free Spin\",\n    \"image\": \"/images/freespin.png\",\n    \"chance\": 0.1\n  },\n  {\n    \"label\": \"No Bonus\",\n    \"image\": \"/images/nobonus.png\",\n    \"chance\": 0.6\n  }\n]\n```\n2. Create placeholder images in the public/images directory:\n   - Create simple SVG or PNG images for each wheel segment\n   - Ensure images are appropriately sized (e.g., 200x200px)\n   - Use distinct colors and icons for each segment type\n3. Create a script to generate placeholder images if needed:\n```typescript\n// scripts/generate-placeholders.ts\nimport fs from 'fs';\nimport path from 'path';\n\nconst colors = {\n  'Bonus 10%': '#FF5733',\n  'Bonus 20%': '#33FF57',\n  'Bonus 5%': '#5733FF',\n  'Free Spin': '#FFFF33',\n  'No Bonus': '#CCCCCC'\n};\n\nfunction generateSVG(label: string, color: string): string {\n  return `<svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect width=\"200\" height=\"200\" fill=\"${color}\" />\n    <text x=\"100\" y=\"100\" font-family=\"Arial\" font-size=\"20\" text-anchor=\"middle\" fill=\"white\">${label}</text>\n  </svg>`;\n}\n\nasync function generatePlaceholders() {\n  const configPath = path.join(process.cwd(), 'config', 'wheel.json');\n  const configData = await fs.promises.readFile(configPath, 'utf8');\n  const config = JSON.parse(configData);\n  \n  const imagesDir = path.join(process.cwd(), 'public', 'images');\n  \n  // Create images directory if it doesn't exist\n  if (!fs.existsSync(imagesDir)) {\n    fs.mkdirSync(imagesDir, { recursive: true });\n  }\n  \n  for (const segment of config) {\n    const imagePath = segment.image.startsWith('/') \n      ? segment.image.substring(1) \n      : segment.image;\n    const fullPath = path.join(process.cwd(), 'public', imagePath);\n    \n    // Create directory if it doesn't exist\n    const dir = path.dirname(fullPath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n    \n    // Generate SVG\n    const color = colors[segment.label] || '#999999';\n    const svg = generateSVG(segment.label, color);\n    \n    // Write SVG file\n    fs.writeFileSync(fullPath, svg);\n    console.log(`Generated placeholder image: ${fullPath}`);\n  }\n}\n\ngeneratePlaceholders().catch(console.error);\n```\n4. Add a script to package.json to run the placeholder generator:\n```json\n\"scripts\": {\n  \"generate-placeholders\": \"ts-node scripts/generate-placeholders.ts\"\n}\n```",
        "testStrategy": "Verify that all placeholder images are generated correctly. Test the wheel with the sample configuration to ensure all segments display properly. Check that the images are appropriately sized and visible on both desktop and mobile devices.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Performance Optimization",
        "description": "Optimize the application for performance, especially the wheel animation and database operations.",
        "details": "1. Optimize wheel rendering with React.memo and useCallback:\n```typescript\n// In components/Wheel.tsx\nimport React, { useState, useRef, useEffect, useCallback, memo } from 'react';\n\n// Use memo to prevent unnecessary re-renders\nconst Wheel = memo(({ segments, onSpinComplete, disabled = false, selectedSegment = null }: WheelProps) => {\n  // ... component implementation\n  \n  // Use useCallback for event handlers\n  const handleSpin = useCallback(() => {\n    if (disabled || spinning || !selectedSegment) return;\n    \n    // ... spin logic\n  }, [disabled, spinning, selectedSegment, segments, rotation]);\n  \n  // ... rest of component\n});\n\nexport default Wheel;\n```\n2. Optimize image loading with next/image priority and placeholder:\n```tsx\n<Image \n  src={segment.image} \n  alt={segment.label}\n  layout=\"fill\"\n  objectFit=\"cover\"\n  priority={index < 2} // Prioritize loading first two segments\n  placeholder=\"blur\"\n  blurDataURL=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'%3E%3Crect width='40' height='40' fill='%23f0f0f0'/%3E%3C/svg%3E\"\n/>\n```\n3. Optimize database operations with connection pooling:\n```typescript\n// In lib/db.ts\nimport sqlite3 from 'sqlite3';\nimport { open, Database } from 'sqlite';\n\nlet dbInstance: Database | null = null;\n\nexport async function openDb() {\n  if (dbInstance) {\n    return dbInstance;\n  }\n  \n  dbInstance = await open({\n    filename: './database.sql',\n    driver: sqlite3.Database\n  });\n  \n  return dbInstance;\n}\n```\n4. Add Next.js performance optimizations:\n```typescript\n// In next.config.js\nmodule.exports = {\n  reactStrictMode: true,\n  images: {\n    domains: [],\n  },\n  experimental: {\n    optimizeCss: true,\n  },\n  webpack(config) {\n    return config;\n  },\n}\n```\n5. Add preloading for the game page:\n```tsx\n// In pages/index.tsx\nimport Head from 'next/head';\n\n// Add to the Head component\n<Head>\n  <link rel=\"preload\" href=\"/api/wheel-config\" as=\"fetch\" crossOrigin=\"anonymous\" />\n</Head>\n```",
        "testStrategy": "Measure performance using Lighthouse and Chrome DevTools. Compare before and after optimization metrics. Test wheel animation smoothness on lower-end devices. Verify database operations are efficient with multiple concurrent users. Check image loading performance with network throttling.",
        "priority": "low",
        "dependencies": [
          6,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Documentation and Deployment",
        "description": "Create documentation for the application and prepare it for deployment.",
        "details": "1. Create a README.md file with project documentation:\n```markdown\n# Bonus App\n\nA gamified experience where users spin a wheel to randomly win a reward. The outcome is controlled via JSON configuration to determine the chance and visual representation of each section.\n\n## Features\n\n- Interactive, visually appealing roulette-style game\n- Each URL represents a unique, single-playable game instance\n- Configurable wheel sections and probabilities through JSON\n- Mobile-first responsive design\n\n## Tech Stack\n\n- Next.js (TypeScript)\n- TailwindCSS\n- SQLite\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 14+ and npm\n\n### Installation\n\n1. Clone the repository\n   ```bash\n   git clone https://github.com/yourusername/bonus-app.git\n   cd bonus-app\n   ```\n\n2. Install dependencies\n   ```bash\n   npm install\n   ```\n\n3. Generate placeholder images (optional)\n   ```bash\n   npm run generate-placeholders\n   ```\n\n4. Start the development server\n   ```bash\n   npm run dev\n   ```\n\n5. Open [http://localhost:3000](http://localhost:3000) in your browser\n\n## Configuration\n\n### Wheel Configuration\n\nThe wheel is configured via a JSON file located at `config/wheel.json`. Each segment has the following properties:\n\n- `label`: Text displayed on the segment\n- `image`: Path to the image for the segment\n- `chance`: Probability of landing on this segment (all chances should sum to 1)\n\nExample configuration:\n\n```json\n[\n  {\n    \"label\": \"Bonus 10%\",\n    \"image\": \"/images/bonus10.png\",\n    \"chance\": 0.1\n  },\n  {\n    \"label\": \"No Bonus\",\n    \"image\": \"/images/nobonus.png\",\n    \"chance\": 0.9\n  }\n]\n```\n\n## Database\n\nThe application uses SQLite to store game data. The database file is located at `database.sql` and is created automatically when the application starts.\n\n### Schema\n\n```sql\nCREATE TABLE games (\n  id TEXT PRIMARY KEY,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  played BOOLEAN DEFAULT 0,\n  result_label TEXT,\n  result_image TEXT\n);\n```\n\n## Deployment\n\n### Vercel\n\nThe easiest way to deploy the application is using Vercel:\n\n1. Push your code to a GitHub repository\n2. Import the project in Vercel\n3. Deploy\n\nNote: For SQLite persistence on Vercel, you'll need to use a custom solution like Vercel Postgres or another database service.\n\n### Docker\n\nAlternatively, you can deploy using Docker:\n\n```bash\n# Build the Docker image\ndocker build -t bonus-app .\n\n# Run the container\ndocker run -p 3000:3000 -v $(pwd)/database.sql:/app/database.sql bonus-app\n```\n\n## License\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n```\n2. Create a Dockerfile for containerized deployment:\n```dockerfile\nFROM node:16-alpine\n\nWORKDIR /app\n\n# Copy package.json and package-lock.json\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci\n\n# Copy the rest of the application\nCOPY . .\n\n# Build the application\nRUN npm run build\n\n# Expose the port\nEXPOSE 3000\n\n# Start the application\nCMD [\"npm\", \"start\"]\n```\n3. Add deployment scripts to package.json:\n```json\n\"scripts\": {\n  \"dev\": \"next dev\",\n  \"build\": \"next build\",\n  \"start\": \"next start\",\n  \"lint\": \"next lint\",\n  \"generate-placeholders\": \"ts-node scripts/generate-placeholders.ts\",\n  \"docker-build\": \"docker build -t bonus-app .\",\n  \"docker-run\": \"docker run -p 3000:3000 -v $(pwd)/database.sql:/app/database.sql bonus-app\"\n}\n```\n4. Create a .env.example file with environment variables:\n```\n# Database configuration\nDATABASE_PATH=./database.sql\n\n# Application configuration\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n```",
        "testStrategy": "Verify the README contains all necessary information for setup and deployment. Test the Docker build and run process. Check that the application runs correctly in a containerized environment. Ensure all environment variables are documented and work as expected.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-01T16:27:33.848Z",
      "updated": "2025-08-01T16:45:03.471Z",
      "description": "Tasks for master context"
    }
  }
}